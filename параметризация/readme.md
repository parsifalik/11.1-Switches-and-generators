<i>    Параметризация тестов — это запуск одного и того же теста с различными входными данными.
    
Это позволяет проверить работу тестируемой функции в разных условиях и с разными наборами данных.

    @pytest.mark.parametrize
     — конструкция (декоратор), которая используется для запуска одного и того же теста с различными входными данными.
Рассмотрим, как реализовать параметризацию. Конструкция `pytest.mark.parametrize` позволяет определить набор параметров 
для теста и их возможные значения.
Основной синтаксис конструкции `pytest.mark.parametrize`

     выглядит следующим образом:
     @pytest.mark.parametrize("параметры", [(значения_1), (значения_2), ..., (значения_n)])

    Где:
        "параметры"
         — это строка, содержащая имена параметров, разделенные запятыми. 
         Эти параметры будут использоваться в тестовой функции.
        [значения] 
         — список кортежей, где каждый кортеж содержит набор значений для параметров. 
         Количество элементов в каждом кортеже должно соответствовать количеству параметров.
Рассмотрим пример:

    import pytest
    
    @pytest.mark.parametrize("x, y, expected", [(1, 2, 3), (4, 5, 9), (7, 8, 15)])
    def test_add(x, y, expected):
        assert x + y == expected

В этом примере параметры `x`, `y` и `expected` будут последовательно принимать значения из каждого кортежа в списке 
[значения], и тест `test_add` будет выполнен для каждого набора параметров. Таким образом мы получим не один тест, а три.

Рассмотрим другой пример. Если у нас есть функция для вычисления факториала числа, мы можем определить параметры
`n` и `expected_result`, где `n` 
— это число, для которого вычисляется факториал, а `expected_result`
— это ожидаемый результат.

В данном примере используется рекурсия. 

<b><i>Рекурсия — это такое поведение функции, при котором функция внутри вызывает сама себя.</i></b>
    
    Не пугайтесь такого использования функций. Главное, чтобы вы понимали, 
    как работает ваша функция, и могли предотвратить бесконечное выполнение.

    import pytest
    
    def factorial(n):
        if n == 0:
            return 1
        else:
            return n * factorial(n-1)
    
    @pytest.mark.parametrize("n, expected_result", [(0, 1), (1, 1), (2, 2), (3, 6), (4, 24)])
    def test_factorial(n, expected_result):
        assert factorial(n) == expected_result

В приведенном выше примере мы определяем параметры n и expected_result через декоратор 
pytest.mark.parametrize. После этого мы задаем набор значений для каждого параметра в виде списка кортежей. 
В данном случае мы запускаем тест пять раз с разными значениями параметров n и expected_result

<b><i>Использование параметризации в тестах значительно сокращает количество кода и упрощает процесс написания тестов. 
Вместо того чтобы писать отдельные тесты для каждого варианта входных данных, 
вы можете определить параметры и их значения один раз и запустить тест на всех возможных комбинациях параметров.</i></b>

<h2>Задача. Тест с параметрами</h2>
Необходимо написать функцию reverse_string(), которая переворачивает строку задом наперед. 
А также написать к этой функции тесты на pytest.

<h3>Решение</h3>

Напишем функцию:

    def reverse_string(string):
        return string[::-1]

Для тестирования данной функции напишем тесты с использованием параметризации:

    import pytest
    
    @pytest.mark.parametrize("string, expected_result", [
        ("hello", "olleh"),
        ("world", "dlrow"),
        ("12345", "54321"),
        ("", ""),
    ])
    def test_reverse_string(string, expected_result):
        assert reverse_string(string) == expected_result

    В тестах используется параметризация, 
    где для каждого случая тестируется разная строка и ожидаемый результат. 
    Для каждой строки мы ожидаем, что результат, 
    возвращаемый функцией reverse_string()
    будет равен ожидаемому результату.


<h2>пример теста с использованием параметризации:</h2>


    import pytest
    
    @pytest.mark.parametrize("a, b, expected", [
        (1, 2, 3),
        (-1, 3, 2),
        (5, -5, 0),
        (0, 0, 0)
    ])
    def test_add_numbers(a, b, expected):
        """
        Проверяем, что функция add_numbers корректно складывает два числа.
        """
        result = add_numbers(a, b)
        assert result == expected
</i>
