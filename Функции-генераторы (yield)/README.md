***Генераторная функция — это функция, использующая ключевое слово `yield`, чтобы возвращать итерируемый объект, 
который может генерировать значения по запросу, вместо того чтобы создавать список значений заранее.***

Преимущества использования функций-генераторов:
- Эффективное использование памяти. Генераторы не хранят все значения в памяти сразу, что позволяет обрабатывать 
большие последовательности данных.
- «Ленивые» вычисления. Генераторы выполняют вычисления только по мере необходимости.

Генераторные функции могут быть очень полезными для работы с большими объемами данных, когда не хватает памяти 
для хранения всех значений одновременно.
Рассмотрим пример. Допустим, нам нужно создать последовательность чисел, где каждый элемент будет увеличиваться 
в экспоненциальной прогрессии. Если бы нам нужно было просто распечатать эти числа, код мог бы выглядеть так:

    def iterate(x0, m):
        x = x0
        while True:
            print(x)
            x *= m
    
    iterate(1, 1.1)
    
    print("impossible!")

Однако этот код приведет к бесконечному выводу чисел, и следующая часть кода `print("impossible!")` 
никогда не выполнится. Если бы мы попробовали заменить `print()` на `return`, то это также привело бы 
к преждевременному завершению процесса генерации последовательности.

Чтобы решить эту проблему, мы можем использовать `yield`
## Ключевое слово `yield`
***`yield` — это ключевое слово, используемое внутри функций-генераторов для создания объектов, которые могут 
быть итерированы.***
Как работает `yield`:
- Когда функция-генератор встречает оператор `yield`, выполнение функции приостанавливается и текущее состояние сохраняется.
- Значение, указанное справа от `yield`, возвращается в вызывающий код.
- При следующем вызове метода функции `next()` выполнение функции возобновляется с сохраненного состояния и 
продолжается до следующего `yield`.
![](https://cdn-user36618.skyeng.ru/skyconvert/unsafe/fit-in/684x/https://cdn-user12724.skyeng.ru/image/ec1e922ca6bd8aebd2e067e7e4a3559b.png)

Рассмотрим пример:

    def simple_generator():
        yield 1
        yield 2
        yield 3
    
    gen = simple_generator()
    
    print(next(gen))
    >>> 1
    print(next(gen)) 
    >>> 2
    print(next(gen))
    >>> 3

Этот пример создает простой генератор `simple_generator()`, который возвращает числа от `1` до `3`. Когда вызывается
`next()`, выполнение функции-генератора приостанавливается после каждого оператора `yield`, и значение справа от
`yield` возвращается. Таким образом, при каждом вызове `next()` мы получаем следующее число из последовательности.

## Генератор в цикле
Генераторы можно использовать в циклах для автоматической итерации:

    for value in simple_generator():
        print(value)
    
    >>> 1
        2
        3
В этом примере генератор используется в цикле, что позволяет удобно перебирать все значения последовательности 
без явного вызова `next()`. Цикл завершится, когда генератор исчерпает все значения.

### Будьте внимательны:
- ***Функция-генератор выполняется только до первого оператора `yield`. Вы не можете использовать `return`
внутри функции-генератора.***
- ***Когда генератор завершает выполнение, вызывается исключение `StopIteration`
указывающее на конец итерации. Его необходимо обработать.***

## Генератор бесконечной последовательности чисел
Рассмотрим генератор бесконечной последовательности чисел:

    def infinite_sequence(start=1):
        while True:
            yield start
            start += 1
    
    numbers = infinite_sequence()
    print(next(numbers))
    >>> 1
    print(next(numbers))
    >>> 2
    # ...

- `infinite_sequence` — это генераторная функция, которая определена с использованием ключевого слова
`yield`. Это означает, что она не выполняется сразу полностью, как обычная функция, а возвращает генератор, 
который может быть использован для последовательного извлечения значений.
- `while True`: — бесконечный цикл, который гарантирует, что генератор будет продолжать возвращать 
значения бесконечно.
- `yield start` — ключевое слово `yield` указывает, что функция возвращает значение `start`
и приостанавливает свое выполнение. При следующем вызове `next()` выполнение возобновляется с этой точки.
- `start += 1` — каждый раз, когда генератор вновь возобновляет выполнение, значение
`start` увеличивается на единицу.

Этот пример иллюстрирует создание бесконечного генератора `infinite_sequence()`
который возвращает числа, начиная с 1 и увеличиваясь на единицу с каждым вызовом `next()`
Такой генератор полезен, когда вам нужно работать с бесконечной последовательностью и извлекать значения 
по мере необходимости.

## Пример генерации геометрической прогрессии
Для генерации последовательности напишем генератор и используем ключевое слово `yield`:

    def iterate(x0, m):
        x = x0
        while True:
            yield x  # вместо print()
            x *= m

При вызове функции `iterate(1, 1.1)` она возвращает генераторный объект, который представляет собой 
бесконечную последовательность. Реализуем генерацию геометрической прогрессии, где каждый последующий элемент 
последовательности получается умножением предыдущего на фиксированный множитель (в данном случае `1.2`), 
начиная с начального значения `1`.

    for n in iterate(1, 1.2):
        print(n)
        if n > 3:
            break
    
    >>> 1
        1.2
        1.44
        1.728
        2.0736
        2.48832
        2.9859839999999997
        3.5831807999999996
Давайте разберем подробнее, как работает этот код:
- `for n in iterate(1, 1.2)`: — создание цикла for, который итерируется по значениям, возвращаемым генератором
`iterate(1, 1.2)`.
- `print(n)` — вывод значения `n`.
- `if n > 3:` `break` — проверка условия, если значение `n` становится больше `3`, 
то цикл завершается с использованием `break`.

Результат:
- В каждой итерации цикла выводится текущее значение `n`
которое получается путем умножения предыдущего значения на множитель `1.2`.
- Выполнение цикла продолжается до тех пор, пока `n` не превысит `3`, 
после чего цикл завершается с использованием `break`.
- Выводятся значения, представляющие экспоненциальный рост, начиная от `1` и умножаясь на `1.2` на каждой итерации, 
пока не достигнет значения более `3`.

Теперь вызывающая сторона кода решает, когда и сколько элементов получить из генератора. 
Генераторная функция не заботится о том, сколько элементов ей нужно генерировать.
Такое решение позволяет создавать бесконечные последовательности без нагрузки на память и вычислительные ресурсы.