## ЗАДАЧА 2
Разберем альтернативную задачу.

У вас есть последовательность чисел от 0 до 19. Необходимо создать конвейер обработки данных с помощью функций
filter map и chain. Отфильтруйте только четные числа из исходной последовательности.
Каждому четному числу из отфильтрованной последовательности добавьте такое же число, создавая пары одинаковых значений.
Объедините пары чисел в одну последовательность, чтобы получить итоговый результат.

### Решение 1

Решением задачи будет следующий код:

    # Функция-предикат для опредления четности числа
    def is_even(x):
        return x % 2 == 0
    
    # Пример фильтрации с использованием filter()
    result_filter = list(filter(is_even, range(20)))
    # Вывод: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
    
    # Функция удваивания числа
    def dup(x):
        return [x, x]
    
    # Пример преобразования с использованием map()
    result_map = list(map(dup, result_filter))
    # Вывод: [[0, 0], [2, 2], [4, 4], [6, 6], ..., [18, 18]]
    
    # Объединяем списки в единый список, распаковывая элементы
    from itertools import chain
    result_chain = list(chain(*result_map))
    # Вывод: [0, 0, 2, 2, 4, 4, 6, 6, 8, 8, ..., 18, 18]

Разберем, что происходит в коде:

1) В конструкции filter(is_even, range(20)):
    - range(20) — создает последовательность чисел от 0 до 19.
    - is_even — функция-предикат, возвращает True для четных чисел.
   
    Функция filter(is_even, range(20)) фильтрует четные числа из диапазона.

2) В конструкции map(dup, result_filter):
    - dup — функция, удваивающая каждый элемент.
    - result_filter — результат предыдущего шага, содержит четные числа.
   
    Функция map(dup, result_filter) удваивает каждое четное число.

3) В конструкции list(chain(*result_map)):
    - chain(*result_map) — разворачивает вложенные списки. Оператор звездочка (*) распаковывает вложенные в последовательность элементы.

Функция list(chain(*result_map)) объединяет полученные списки в единый список, распаковывая элементы.

### Решение 2
Для этой задачи есть способ решения в одну строку. Синтаксис с lambda и функцией chain() будет следующий:

      # Вариант в виде однострочника
      result_lambda = list(chain(*map(lambda x: [x, x], filter(lambda x: x % 2 == 0, range(20)))))
      # Вывод: [0, 0, 2, 2, 4, 4, 6, 6, 8, 8, ..., 18, 18]

Сделаем пошаговый синтаксический разбор:
1) В блоке filter(lambda x: x % 2 == 0, range(20)):
- lambda x: x % 2 == 0 — анонимная функция-предикат, возвращает True для четных чисел.

Функция filter(lambda x: x % 2 == 0, range(20)) фильтрует четные числа из диапазона.

2) В блоке map(lambda x: [x, x], result_lambda):
- lambda x: [x, x] — анонимная функция, удваивающая каждый элемент.
- result_lambda — результат предыдущего шага, содержит четные числа.

Функция map(lambda x: [x, x], result_lambda) удваивает каждое четное число.

3) В блоке list(chain(*result_lambda)):

- chain(*result_lambda) — разворачивает вложенные списки.

Функция list(chain(*result_lambda)) объединяет полученные списки в единый список, распаковывая элементы.

***Такой подход упрощает код, делает его более читаемым и позволяет строить конвейеры данных, 
обрабатывая элементы пошагово. Это полезно, когда у вас есть сложные операции обработки данных, 
и вы хотите разделить их на более мелкие шаги.***



