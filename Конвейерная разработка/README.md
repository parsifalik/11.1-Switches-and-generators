## Что такое конвейер для данных

Представьте, что у вас есть база данных с информацией о пользователях, и каждый пользователь представлен 
в виде словаря с различными характеристиками: имя, возраст, страна и т. д. 
Вам необходимо выполнить следующие операции:

- Фильтрация. Отобрать только тех пользователей, которые старше 25 лет и находятся в стране с кодом US.
- Преобразование. Увеличить возраст каждого отфильтрованного пользователя на два года.
- Разворачивание данных. Преобразовать каждого пользователя в два пользователя 
  с идентичными характеристиками.

Чтобы выполнить все перечисленные операции с последовательностями данных, используют конвейер для данных.

***Конвейер для данных — это структура, которая представляет собой последовательность операций обработки 
данных, где результат каждой операции передается на вход следующей.***

Этот подход позволяет разбить сложные задачи на более простые шаги, выполнение которых происходит 
последовательно.
![](https://cdn-user36618.skyeng.ru/skyconvert/unsafe/fit-in/684x/https://cdn-user12724.skyeng.ru/image/e152fbc2c4fcf6630eeae54414f5b804.png)

Основные компоненты конвейера для данных включают:

    
- Итераторы и итерируемые объекты. Конвейеры для данных работают с последовательностями данных, 
  такими как списки, кортежи или другие итерируемые объекты.
- Преобразования данных (Transformations). Это операции, которые изменяют данные. 
  Например, преобразование числа в другое число, преобразование строки, фильтрация данных и т. д.
- Связывание данных (Chaining). Этот шаг связывает результат одной операции с входом следующей. 
  Обычно используется для объединения последовательных шагов в конвейере.
- Потребители данных (Consumers). Это конечные операции, которые используют или сохраняют результаты 
  конвейера. Например, вывод на экран, запись в файл, сохранение в базу данных и т. д.

***Применение конвейера для данных улучшает читаемость кода, делает его более модульным и облегчает поддержку.***

## Преобразования и фильтрация данных
Конвейер состоит из двух видов операций:

- Преобразование отдельных элементов.
- Изменение состава элементов — фильтрация или размножение.

Разберем основные функции, которые используются в конвейерах.

### Функция map()
***Функция `map()` — применяет указанную в аргументе функцию ко всем элементам входной последовательности и 
возвращает итератор с результатами.***

Синтаксис функции:
`map_result = map(function, iterable)`
- `function` — функция, которая будет применена к каждому элементу последовательности.
- `iterable` — последовательность, элементы которой будут переданы в функцию.

Пример использования функции `map()`:

    # Удвоить каждый элемент списка
    numbers = [1, 2, 3, 4, 5]
    doubled_numbers = map(lambda x: x * 2, numbers)

В данном примере происходит удвоение каждого элемента списка numbers с использованием функции
`map()` и лямбда-функции.

Разберем этот код:

- Функция map() принимает два аргумента: функцию и итерируемый объект 
(в данном случае список numbers ). Функция map()
применяет указанную функцию к каждому элементу итерируемого объекта.

- Лямбда-функция `lambda x: x * 2` — это анонимная функция, которая берет один аргумент
`x` и возвращает `x * 2`. В контексте функции `map() x`
будет последовательно принимать значения каждого элемента из списка `numbers`

- Результатом работы функции `map()` будет объект, который содержит результаты удвоения 
каждого элемента списка `numbers`. Например, первый элемент списка 1 удваивается до 2, 
второй элемент 2 удваивается до 4 и так далее.

Чтобы получить результат в виде списка, можно преобразовать объект `map` в список с помощью функции `list()`

Например:

`doubled_numbers = list(map(lambda x: x * 2, numbers))`

Теперь `doubled_numbers` будет содержать `[2, 4, 6, 8, 10]`, что соответствует удвоенным значениям 
исходного списка numbers

### Функция filter()
***Функция filter() — фильтрует элементы из входной последовательности на основе заданного условия.***

Синтаксис функции:

`filter_result = filter(predicate, iterable)`

- predicate — функция, возвращающая True или False
для каждого элемента. Элементы, для которых возвращается
True, сохраняются в новую последовательность.

***Функции-предикаты (или просто предикаты) — это функции, которые возвращают булево значение
True или False в зависимости от того, выполняется ли какое-то условие. Иными словами, 
они проверяют некоторое утверждение и возвращают ответ на вопрос: «Верно ли это утверждение?»***

- `iterable` — последовательность, которую нужно отфильтровать.

Пример использования функции filter():

    # Оставить только четные числа
    numbers = [1, 2, 3, 4, 5]
    even_numbers = filter(lambda x: x % 2 == 0, numbers)
В этом примере происходит фильтрация списка numbers для того, чтобы оставить в нем только четные числа, 
используя функцию filter() в сочетании с лямбда-функцией.

Давайте подробнее рассмотрим каждый шаг:
- Функция filter() принимает два аргумента: функцию и итерируемый объект.
filter() применяет переданную в качестве аргумента функцию к каждому элементу итерируемого 
объекта и возвращает новый итератор с теми элементами, для которых функция вернула True

- Лямбда-функция `lambda x: x % 2 == 0` проверяет, делится ли число `x` на 2 без остатка. 
Если `x` четное, то есть `x % 2` равно `0`, функция возвращает `True`

- Результатом работы функции `filter()` будет объект, который содержит только те элементы из списка
`numbers`, которые удовлетворяют условию четности (деление на 2 без остатка). 
Например, из исходного списка `1, 2, 3, 4, 5` четными являются `2` и `4`

Для преобразования результата в список можно использовать функцию `list()`

Пример:

`even_numbers = list(filter(lambda x: x % 2 == 0, numbers))`

После этого преобразования `even_numbers` будет содержать `[2, 4]`, 
что представляет собой четные числа из исходного списка `numbers`

### Функция chain()

***Функция chain() — объединяет несколько последовательностей в одну.***

Чтобы работать с функцией chain, ее необходимо импортировать из модуля itertools:

    from itertools import chain
    chained_result = chain(iterable1, iterable2, ...)

- iterable1, iterable2, ...
— последовательности, которые нужно объединить.

Пример использования функции chain():

    # Объединить два списка в один
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    combined_list = list(chain(list1, list2))












