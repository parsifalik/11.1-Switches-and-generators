<i>
<h2>Что такое конвейер для данных</h2>

Представьте, что у вас есть база данных с информацией о пользователях, и каждый пользователь представлен 
в виде словаря с различными характеристиками: имя, возраст, страна и т. д. 
Вам необходимо выполнить следующие операции:

- Фильтрация. Отобрать только тех пользователей, которые старше 25 лет и находятся в стране с кодом US.
- Преобразование. Увеличить возраст каждого отфильтрованного пользователя на два года.
- Разворачивание данных. Преобразовать каждого пользователя в два пользователя 
  с идентичными характеристиками.

Чтобы выполнить все перечисленные операции с последовательностями данных, используют конвейер для данных.

***Конвейер для данных — это структура, которая представляет собой последовательность операций обработки 
данных, где результат каждой операции передается на вход следующей.***

Этот подход позволяет разбить сложные задачи на более простые шаги, выполнение которых происходит 
последовательно.

![](https://cdn-user36618.skyeng.ru/skyconvert/unsafe/fit-in/684x/https://cdn-user12724.skyeng.ru/image/e152fbc2c4fcf6630eeae54414f5b804.png)

Основные компоненты конвейера для данных включают:

    
- Итераторы и итерируемые объекты. Конвейеры для данных работают с последовательностями данных, 
  такими как списки, кортежи или другие итерируемые объекты.
- Преобразования данных (Transformations). Это операции, которые изменяют данные. 
  Например, преобразование числа в другое число, преобразование строки, фильтрация данных и т. д.
- Связывание данных (Chaining). Этот шаг связывает результат одной операции с входом следующей. 
  Обычно используется для объединения последовательных шагов в конвейере.
- Потребители данных (Consumers). Это конечные операции, которые используют или сохраняют результаты 
  конвейера. Например, вывод на экран, запись в файл, сохранение в базу данных и т. д.

***Применение конвейера для данных улучшает читаемость кода, делает его более модульным и облегчает поддержку.***

## Преобразования и фильтрация данных
Конвейер состоит из двух видов операций:

- Преобразование отдельных элементов.
- Изменение состава элементов — фильтрация или размножение.

Разберем основные функции, которые используются в конвейерах.

### Функция map()
***Функция `map()` — применяет указанную в аргументе функцию ко всем элементам входной последовательности и 
возвращает итератор с результатами.***

Синтаксис функции:
`map_result = map(function, iterable)`
- `function` — функция, которая будет применена к каждому элементу последовательности.
- `iterable` — последовательность, элементы которой будут переданы в функцию.

Пример использования функции `map()`:

    # Удвоить каждый элемент списка
    numbers = [1, 2, 3, 4, 5]
    doubled_numbers = map(lambda x: x * 2, numbers)

В данном примере происходит удвоение каждого элемента списка numbers с использованием функции
`map()` и лямбда-функции.

Разберем этот код:

- Функция map() принимает два аргумента: функцию и итерируемый объект 
(в данном случае список numbers ). Функция map()
применяет указанную функцию к каждому элементу итерируемого объекта.

- Лямбда-функция `lambda x: x * 2` — это анонимная функция, которая берет один аргумент
`x` и возвращает `x * 2`. В контексте функции `map() x`
будет последовательно принимать значения каждого элемента из списка `numbers`

- Результатом работы функции `map()` будет объект, который содержит результаты удвоения 
каждого элемента списка `numbers`. Например, первый элемент списка 1 удваивается до 2, 
второй элемент 2 удваивается до 4 и так далее.

Чтобы получить результат в виде списка, можно преобразовать объект `map` в список с помощью функции `list()`

Например:

`doubled_numbers = list(map(lambda x: x * 2, numbers))`

Теперь `doubled_numbers` будет содержать `[2, 4, 6, 8, 10]`, что соответствует удвоенным значениям 
исходного списка numbers

<details>
<summary><h2>Дополнительный материал по <code>map</code></h2></summary>
В Python <code>iterable</code> в контексте функции <code>map()</code> означает любую коллекцию или последовательность, 
элементы которой можно поочередно обработать. Это включает в себя:

- Списки (`lists`)
- Кортежи (`tuples`)
- Строки (`strings`)
- Множества (`sets`)
- Словари (`dictionaries`)
- Диапазоны (`ranges`)
- Любые другие объекты, реализующие метод `__iter__` или `__getitem__`

<h3>Примеры использования <code>map()</code> с различными типами <code>iterable</code>:</h3>

<b>Список:</b>

    numbers = [1, 2, 3, 4, 5]
    squared_numbers = map(lambda x: x**2, numbers)
    print(list(squared_numbers))  # Вывод: [1, 4, 9, 16, 25]

<b>Кортеж:</b>

    numbers_tuple = (1, 2, 3, 4, 5)
    squared_numbers_tuple = map(lambda x: x**2, numbers_tuple)
    print(tuple(squared_numbers_tuple))  # Вывод: (1, 4, 9, 16, 25)

<b>Строка:</b>

    chars = "hello"
    upper_chars = map(lambda x: x.upper(), chars)
    print(''.join(upper_chars))  # Вывод: HELLO

<b>Множество:</b>

    numbers_set = {1, 2, 3, 4, 5}
    squared_numbers_set = map(lambda x: x**2, numbers_set)
    print(set(squared_numbers_set))  # Вывод: {1, 4, 9, 16, 25}

<b>Словарь:</b>

    numbers_dict = {'a': 1, 'b': 2, 'c': 3}
    squared_values = map(lambda x: x**2, numbers_dict.values())
    print(list(squared_values))  # Вывод: [1, 4, 9, 16, 25]

<b>Диапазон:</b>

    numbers_range = range(1, 6)
    squared_numbers_range = map(lambda x: x**2, numbers_range)
    print(list(squared_numbers_range))  # Вывод: [1, 4, 9, 16, 25]

</details>

### Функция filter()
***Функция filter() — фильтрует элементы из входной последовательности на основе заданного условия.***

Синтаксис функции:

`filter_result = filter(predicate, iterable)`

- predicate — функция, возвращающая True или False
для каждого элемента. Элементы, для которых возвращается
True, сохраняются в новую последовательность.

***Функции-предикаты (или просто предикаты) — это функции, которые возвращают булево значение
True или False в зависимости от того, выполняется ли какое-то условие. Иными словами, 
они проверяют некоторое утверждение и возвращают ответ на вопрос: «Верно ли это утверждение?»***

- `iterable` — последовательность, которую нужно отфильтровать.

Пример использования функции filter():

    # Оставить только четные числа
    numbers = [1, 2, 3, 4, 5]
    even_numbers = filter(lambda x: x % 2 == 0, numbers)
В этом примере происходит фильтрация списка numbers для того, чтобы оставить в нем только четные числа, 
используя функцию filter() в сочетании с лямбда-функцией.

Давайте подробнее рассмотрим каждый шаг:
- Функция filter() принимает два аргумента: функцию и итерируемый объект.
filter() применяет переданную в качестве аргумента функцию к каждому элементу итерируемого 
объекта и возвращает новый итератор с теми элементами, для которых функция вернула True

- Лямбда-функция `lambda x: x % 2 == 0` проверяет, делится ли число `x` на 2 без остатка. 
Если `x` четное, то есть `x % 2` равно `0`, функция возвращает `True`

- Результатом работы функции `filter()` будет объект, который содержит только те элементы из списка
`numbers`, которые удовлетворяют условию четности (деление на 2 без остатка). 
Например, из исходного списка `1, 2, 3, 4, 5` четными являются `2` и `4`

Для преобразования результата в список можно использовать функцию `list()`

Пример:

`even_numbers = list(filter(lambda x: x % 2 == 0, numbers))`

После этого преобразования `even_numbers` будет содержать `[2, 4]`, 
что представляет собой четные числа из исходного списка `numbers`

<details>
<summary><h2>Доп материал по <code>filter</code></h2></summary>
<h3>Синтаксис:</h3>

>filter_result = filter(function, iterable)

<h3>Параметры:</h3>

- `function`: Функция, которая возвращает `True` или `False` для каждого элемента из `iterable`
- `iterable`: Последовательность, элементы которой нужно отфильтровать.

### Примеры использования `filter()` с различными типами `iterable`:
Список:

    numbers = [1, 2, 3, 4, 5]
    filtered_numbers = filter(lambda x: x % 2 == 0, numbers)
    print(list(filtered_numbers))  # Вывод: [2, 4]

Кортеж:

    numbers_tuple = (1, 2, 3, 4, 5)
    filtered_numbers_tuple = filter(lambda x: x % 2 == 0, numbers_tuple)
    print(tuple(filtered_numbers_tuple))  # Вывод: (2, 4)

Строка:

    chars = "hello"
    filtered_chars = filter(lambda x: x in ['e', 'o'], chars)
    print(''.join(filtered_chars))  # Вывод: "eo"

Множество:

    numbers_set = {1, 2, 3, 4, 5}
    filtered_numbers_set = filter(lambda x: x % 2 == 0, numbers_set)
    print(set(filtered_numbers_set))  # Вывод: {2, 4}

Словарь:

    numbers_dict = {'a': 1, 'b': 2, 'c': 3}
    filtered_values = filter(lambda x: x[1] % 2 == 0, numbers_dict.items())
    print(dict(filtered_values))  # Вывод: {'b': 2}

Диапазон:

    numbers_range = range(1, 6)
    filtered_numbers_range = filter(lambda x: x % 2 == 0, numbers_range)
    print(list(filtered_numbers_range))  # Вывод: [2, 4]
</details>


### Функция chain()

***Функция chain() — объединяет несколько последовательностей в одну.***

Чтобы работать с функцией chain, ее необходимо импортировать из модуля itertools:

    from itertools import chain
    chained_result = chain(iterable1, iterable2, ...)

- iterable1, iterable2, ...
— последовательности, которые нужно объединить.

Пример использования функции chain():

    # Объединить два списка в один
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    combined_list = list(chain(list1, list2))
</i>




